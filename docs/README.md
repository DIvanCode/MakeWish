# Документация

* [Техническое задание](README.md#техническое-задание)
  * [Сущности](README.md#сущности)
  * [Сценарии](README.md#сценарии)
  * [Схема данных](README.md#схема-данных)
* [Архитектура системы](README.md#архитектура-системы)
  * [Микросервисы](README.md#микросервисы)
  * [Взаимодействие](README.md#взаимодействие)
  * [API Gateway](README.md#api-gateway)
  * [Хранилище](README.md#хранилище)
* [Приложения](README.md#приложения)
  * [UserService](README.md#userservice)
    * [Функционал](README.md#функционал)
    * [База данных](README.md#база-данных)
  * [WishService](README.md#wishservice)
    * [Функционал](README.md#функционал-1)
    * [База данных](README.md#база-данных-1)
  * [Desktop](README.md#desktop)
* [Развёртывание](README.md#развертывание)
  * [Локальный запуск для тестирования](README.md#локальный-запуск-для-тестирования)
  * [Общий процесс доставки приложений до хоста](README.md#общий-процесс-доставки-приложений-до-хоста)
  * [Развёртывание в облаке на виртуальной машине](README.md#развёртывание-в-облаке-на-виртуальной-машине)
  * [Развёртывание в кластере Kubernetes](README.md#развёртывание-в-кластере-kubernetes)

# Техническое задание

## Сущности

### Пользователь

- Пользователь имеет уникальный идентификатор, электронную почту, пароль, имя, фамилию.
- Два пользователя могут иметь связь “друзья”.

### Желание

- Желание имеет уникальный идентификатор, название, описание, статус.
- Статус принимает одно из следующих значений:
    - создано
    - удалено
    - обещано
    - исполнено
    - подтверждено

Бизнес-логика статусов:
- если желание только создано, всем показывается статус "создано"
- если желание удалено, всем показывается статус "удалено"
- если желание обещано кем-то кроме владельца, то всем кроме владельца показывается статус "обещано", а владельцу "создано"
- если желание обещано владельцем желания, то всем показывается статус "обещано"
- если желание исполнено кем-то кроме владельца, то всем кроме владельца и этого пользователя показывается "обещано", а им показывается "исполнено"
- если желание исполнено владельцем, то оно получает статус "подтверждено"; всем кроме владельца показывается статус "исполнено", а владельцу "подтверждено"
- если желание подтверждено владельцем, то оно получает статус "подтверждено"; всем кроме владельца и пользователя, исполнившего желание, показывается статус "исполнено", а им показывается "подтверждено"


### Список желаний

- Список желаний имеет уникальный идентификатор, название и содержит в себе ноль или более желаний.

## Сценарии

### Регистрация

- Пользователь имеет возможность зарегистрироваться в системе по электронной почте и паролю.
- При регистрации указываются имя и фамилия.
- Два аккаунта не могут иметь одинаковую электронную почту.
- При регистрации происходит создание публичного и приватного списков желаний, привязанного к этому пользователю.

### Вход

- Для совершения всех действий в системе пользователь должен пройти авторизацию.
- Для идентификации используется электронная почта.
- Для аутентификации используется пароль.
- Для дальнейшей авторизации используется токен, выдаваемый после успешной аутентификации.

### Добавление в друзья - шаг I (создание заявки)

- Пользователь имеет возможность создать заявку на добавление в друзья другого пользователя.
- Пользователь имеет возможность отменить заявку на добавление в друзья другого пользователя, если она еще не была принята.
- Пользователи не должны иметь связь “друзья”.
- В любой момент времени должно существовать не более одной заявки между двумя пользователями.

### Добавление в друзья - шаг II (одобрение заявки)

- Пользователь имеет возможность одобрить заявку на добавление в друзья другого пользователя либо отклонить ее.
- В случае одобрения заявки пользователи начинают иметь связь “друзья”.
- В случае отклонения заявки, она удаляется.
- Каждму из двух пользователей выдаются права на просмотр публичного списка желаний другого пользователя.

### Удаление из друзей

- Пользователь имеет возможность удалить связь “друзья” с другим пользователем.
- Пользователи должны иметь связь “друзья”.

### Просмотр списка своих друзей

- Пользователь имеет возможность посмотреть список пользователей, с которыми имеет связь “друзья”.
- Пользователь имеет возможность посмотреть список пользователей, которые отправили ему заявку в друзья.
- Пользователь имеет возможность посмотреть список пользователей, которым он отправил заявку в друзья, и она еще не была рассмотрена.

### Просмотр списка чужих друзей

- Пользователь имеет возможность посмотреть список пользователей, с которыми другой пользователь имеет связь “друзья”.

### Создание желания

- Пользователь имеет возможность создать желание.
- Пользователь получает связь “владеет” с желанием.
- Ровно один пользователь может иметь связь “владеет” с желанием.
- При создании желание получает статус “создано”.
- При создании желание автоматически попадает в публичный или приватный список желаний пользователя (указывается при создании).

### Редактирование желания

- Пользователь имеет возможность редактировать желание.
- Пользователь должен иметь связь “владеет” с желанием.
- Желание должно иметь статус “создано”.
- При редактировании можно изменить название, описание.

### Удаление желания

- Пользователь имеет возможность удалить желание.
- При этом удаление происходит "мягко", чтобы была возможность восстановить удаленное желание.
- Пользователь должен иметь связь “владеет” с желанием.
- Желание должно иметь статус “создано”.

### Восстановление желания

- Пользователь имеет возможность восстановить желание.
- Пользователь должен иметь связь “владеет” с желанием.
- Желание должно иметь статус "удалено".
- Желание получает статус "создано".

### Просмотр своего желания

- Пользователь имеет возможность посмотреть свое желание.
- Пользователь должен иметь связь “владеет” с желанием.

### Просмотр чужого желания

- Пользователь имеет возможность просмотреть желание, с которым не имеет связь “владеет”.
- Пользователь должен иметь право на просмотр какого-либо списка желаний, который имеет связь “содержит” с этим желанием.

### Создание списка желаний

- Пользователь имеет возможность создать список желаний.
- Пользователь получает связь “владеет” со списком желаний.
- При создании пользователь может добавить желание в список.
- Пользователь должен иметь связь “владеет” с желанием.
- Список желаний получает связь “содержит” с желанием.

### Добавление желания в список желаний

- Пользователь имеет возможность добавить желание в список желаний.
- Пользователь должен иметь связь “владеет” с желанием.
- Пользователь должен иметь связь “владеет” со списком желаний.
- Список желаний не должен иметь связь “содержит” с желанием.
- Список желаний получает связь “содержит” с желанием.
- Желание имеет возможность содержаться в нескольких списках желаний.
- Список желание может содержать желание не более одного раза.

### Просмотр своих желаний

- Пользователь имеет возможность посмотреть все свои желания.
- Должны быть показаны все желания, находящиеся в публичном и приватном основных списках желаний пользователя.

### Просмотр своего списка желаний

- Пользователь имеет возможность посмотреть все желания, находящиеся в определенном списке желаний.
- Пользователь должен иметь связь “владеет” со списком желаний.

### Просмотр чужих желаний

- Пользователь имеет возможность посмотреть желания другого пользователя.
- Если они не обладают связью друзья, никаких желаний не отображается.
- Если они обладают связью друзья, должны быть показаны все желания, находящиеся в публичном основном списке желаний пользователя.

### Просмотр чужого списка желаний

- Пользователь имеет возможность просмотреть список желаний, которым “владеет” другой пользователь.
- Пользователь должен иметь право на просмотр этого списка желаний.

### Выдача права на просмотр своего списка желаний другому пользователю

- Пользователь имеет возможность выдать права на просмотр списка желаний другому пользователю.
- Первый пользователь должен иметь связь “владеет” со списком желаний.
- Второй пользователь получает право на просмотр этого списка желаний.

### Выбор желания другого пользователя для исполнения

- Пользователь имеет возможность обещать исполнение желания.
- Желание должно иметь статус “создано”.
- Желание получает статус "обещано".
- В любой момент времени не более чем один пользователь может иметь связь “обещано” с желанием.
- Пользователь должен иметь доступ к желанию.
- Система запоминает пользователя и связывает с желанием связью “обещал”.

### Просмотр списка обещаных желаний

- Пользователь имеет возможность посмотреть список желаний, с которыми имеет связь "обещал".

### Отказ от исполнения желания другого пользователя

- Пользователь имеет возможность отказаться от исполнения желания.
- Пользователь должен иметь связь "обещал" с желанием.
- Желание получает статус “создано”.

### Исполнение своего желания

- Пользователь имеет возможность исполнить свое желание.
- Пользователь должен иметь связь “владеет” с желанием.
- Желание получает статус “подтверждено”.
- Система запоминает, что желание было обещано и выполнено этим пользователем.

### Исполнение чужого желания

- Пользователь имеет возможность исполнить чужое желание.
- Пользователь должен иметь связь “обещал” с желанием.
- Желание получает статус “исполнено” и должно быть подтверждено владельцем желания.

### Подтверждение исполнения желания

- Пользователь имеет возможность подтвердить, что желание действительно было исполнено.
- Пользователь должен иметь связь “владеет” с желанием.
- Желание должно иметь статус "исполнено".
- При подтверждении желание получает статус “подтверждено”.
- Система запоминает аккаунт пользователя, выполнившего это желание.
- При отклонении желание получает статус “создано”, а система забывает пользователей, обещавших и исполнивших это желание.

## Схема данных

Общая схема сущностей и их отношений выглядит следующим образом:

<img src="/docs/MakeWish.Common.DB.Schema.png" />
<!-- https://drawsql.app/teams/spbu-1/diagrams/makewish-common -->

# Архитектура системы

<img src="/docs/MakeWish.Architecture.png" />
<!-- https://unidraw.io/app/board/ddd575875946b6d0abe8 -->

## Микросервисы

Бизнес-логика разделена на два микросервиса:
1. UserService - сервис, отвечающий за работу с пользователями.
2. WishService - сервис, отвечающий за работу с желаниями.

Оба сервиса будут написаны на C# в рамках курса по .NET в университете. В качестве UI будет Desktop приложение, написанное так же на C#.

## Взаимодействие

В UserService происходят события, на которые WishService должен реагировать.
Для обеспечения низкой связности между микросервисами, а также для уменьшения задержки появления пользователя в WishService будет использован Message Bus, а конкретно RabbitMQ.

Message Bus выбирался из двух вариантов (Kafka и RabbitMQ). Критерии:
- Низкая задержка. Оба варианта обеспечивают достаточно низкую задержку, но в RabbitMQ почти real-time.
- Долговременное хранение не требуется. В RabbitMQ сообщение удаляется после получения.
- Большая нагрузка не ожидается, так как события создания/удаления пользователя и добавления/удаления друзей, поэтому высокая пропускная способность, предоставляемая Kafka, не требуется.
- Настройка, управление, обеспечение жизнеспособности проще сделать с RabbitMQ.

## API Gateway

С внешним миром приложение общается через единую точку входа API Gateway, выполняющего функции обратного прокси и балансировки нагрузки.

## Хранилище

У каждого сервиса есть своя база данных:
1. UserService использует реляционную модель хранения данных.
2. WishService использует графовую модель хранения данных.

# Приложения

## UserService

### Функционал

Сервис отвечает за следующий функционал:
1. Работа с пользователями (создание, удаление).
2. Регистрация, аутентификация.
3. Добавление пользователей в друзья (создание, одобрение, отклонение заявки).

### База данных

Достаточно частые операции - поиск пользователя по email для аутентификации и просмотр списка своих друзей. Нет длинных и сложных связей между сущностями. В качестве базы данных подходит реляционная модель. Будет использоваться Postgresql, как самый простой вариант.

<img src="/docs/MakeWish.UserService.Postgresql.png" />
<!-- https://www.drawdb.app/editor?shareId=271ffeed55b137c7c622fe4d17b8f1ad -->

## WishService

### Функционал

Сервис отвечает за следующий функционал:
1. Работу с моделями желаний (создание, редактирование, удаление, просмотр).
2. Работу со списками желаний (создание, редактирование, удаление, добавление желаний, удаление желаний).
3. Выдача и проверка прав доступа к спискам желаний.
4. Обещание и исполнение желаний.

### База данных

Есть длинные и сложные связи между сущностями. Самой тяжелой операцией является проверка прав доступа на просмотр желания. Если использовать реляционную модель, придется делать 3 join операции. В качестве базы данных достаточно лаконично смотрится графовая модель. Будет использоваться Neo4j, так как у нее достаточно большое комьюнити, поддержка, а также есть клиентский драйвер на C#.

<img src="/docs/MakeWish.WishService.Neo4j.png" />
<!-- https://unidraw.io/app/board/8e404484d622ae0df39a -->

## Desktop

Сервис выступает в роли Desktop-приложения на платформе Windows.

<img src="/docs/MakeWish.Desktop.Design.png" />
<!-- https://unidraw.io/app/board/e5699ffc011409d64978 -->

# Развёртывание

## Локальный запуск для тестирования

Запуск всех компонентов происходит в Docker-контейнерах при помощи [docker-compose.yml](../docker-compose.yml).

Все написанные приложения используют конфигурацию с окружением Development.

<img src="/docs/Deployment.Development.png" />
<!-- https://unidraw.io/app/board/ddd575875946b6d0abe8 -->

## Общий процесс доставки приложений до хоста

При помощи ansible-playbook формируется Docker-образ. Тег определяется через extra-vars. В CI/CD тег ставится равным последнему коммиту.

Собранный образ загружается в хранилище образов DockerHub, откуда впоследствии загружается на хост.

## Развёртывание в облаке на виртуальной машине

UserService, WishService, Neo4j находятся на виртуальной машине FriendlyCrane в облаке timeweb. Развёртывание происходит при помощи ansible-playbook.

Сетевая связность между этими тремя компонентами реализована при помощи Docker, они находятся в одной сети dev.

PostgreSQL и RabbitMQ используются как DBaaS. Развёртывание, управление и поддержка производятся командой timeweb.

Сетевая связность между всеми приложениями достигается при помощи приватной облачной сети.

Все написанные приложения используют конфигурацию с окружением FriendlyCrane.

Затраты:
1. Виртуальная машина FriendlyCrane - 2 CPU, 2 ГБ RAM, 40 ГБ NVMe - 700 руб/мес
   - Использование оперативной памяти без нагрузки - 1.12 ГБ, поэтому пришлось брать 2 ГБ RAM.
2. PostgreSQL as a Service - 1 CPU, 2 ГБ RAM, 8 ГБ NVMe - 230 руб/мес
   - Минимальная конфигурация
3. RabbitMQ as a Service - 2 CPU, 4 ГБ RAM, 10 ГБ NVMe - 750 руб/мес
   - Минимальная конфигурация

<img src="/docs/Deployment.FriendlyCrane.png" />
<!-- https://unidraw.io/app/board/ddd575875946b6d0abe8 -->

## Развёртывание в кластере Kubernetes

Все используемые сервисы находятся в кластере Witty Cetus. Каждое приложение представлено в виде одного пода в пространстве имен makewish.

Для доступа к сервисам извне используется балансировщик нагрузки Ingress, который находится в том же пространстве имён и маршрутизирует трафик на user-service или на wish-service.

Входной точкой является ingress-controller в пространстве имён ingress-nginx и перенаправляет трафик в Ingress.

Все написанные приложения используют конфигурацию с окружением WittyCetus.

Затраты:
1. Кластер Kubernetes - 1 нода: 2 CPU, 2 ГБ RAM, 40 ГБ NVMe
   - Минимальная конфигурация

<img src="/docs/Deployment.WittyCetus.png" />
<!-- https://unidraw.io/app/board/ddd575875946b6d0abe8 -->
